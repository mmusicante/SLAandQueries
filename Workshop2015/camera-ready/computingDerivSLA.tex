%%-----------------------------------------------------------------
%\section{Computing a derived SLA}
%\label{sec:derivedSla}
%%-----------------------------------------------------------------

The key and original aspect of  our proposed data integration and provision process is  defined as a vertical mapping of user QoS preferences and agreed SLA of potentially composable services. 
This  leads to a {\em derived SLA} that guides the evaluation of a query and maps SLA measures and QoS preferences attributes.  




The {\em derived SLA} is defined as a set of measures that correspond to the user preferences computed as a function of different static, computed and hybrid measures. These measures can come from the evaluation of simpler measures expressed in the cloud subscription of the user. 
The {\em derived SLA}  will guide the way the query will be evaluated, and the way results will be computed and delivered.

In the example, some of the user preferences statement measures are used for defining a {\em derived SLA} that, as said before, will guide the evaluation of the query. 
These measures are defined as a function of the measures used by the agreed SLAs and by the cloud SLA contract. For example: 
\begin{trivlist}\sf\footnotesize
 \item[~-~ total cost:] $\sum_{i = 1\dots n}$ cost(s$_i$) + data transfer + encryption cost $\leq$ \$1;
 \item[~-~availability:] {\em (of services involved)} $\geq$ {\sf 90$\%$};
 ~-~freshness: non;
 \item[~-~provenance:] all services involved must be $expert$;
  ~-~duration: 7 days;
 \item[~-~I/0 volume/month:] 8GB;
  ~-~reputation level: $\geq$ threshold;
 \item[~-~storageSpace:] 1GB.
 \end{trivlist} 
 
Therefore, we propose a classification of SLA measures that represents the combination of fine grained measures used by {\em agreed SLAs} and coarse grained measures used in user preferences statements. 
It specifies also how to compute coarse grained measures with fine grained ones. 
For example, data precision will be computed as a function of availability, freshness and provenance exported by data services. The {\em derived SLA} can be seen as a set of inequations that have to be solved during the execution of a service composition. Since some of them can only be determined at execution time, the decision on which services will participate in the evaluation of the query is approximated.  
This latter step may conduct either to the rejection of integration in case of total incompatibility, or to a negotiation step between {\em agreed SLA}s and the {\em derived SLA}. In order to address this problem we introduce the notion of  {\em integration SLA} (defined in  Section \ref{sec:queryProcessOpt}). 
%and thus the need for an adaptive setting.
%Negotiation of implied SLAs depends strongly on the request sent and the services deployed at the arrival time of the application on the involved  clouds (i.e clouds holding services that satisfies user requests and that are candidate to service composition to answer the query). This negotiation can be expensive and may not scale well.
 
%Given a query and its preferences statement, the system  finds  service compositions that produce results meeting the required constraints, as discussed in the following section.
%The resulting derivedSLA will be used in the query rewriting step described in the next section. 
 

