We propose an SLA guided continuous data provision and integration approach that proposes three steps  starting from the processing of the request  to the delivery of the result sets.

Given a requirement expressing a query and quality of service preferences: cost, provenance, reputation, time the system processes it according as follows: (i) SLA global computation for filtering possible data providers; (ii) query rewriting for computing services compositions that can be used for building results; (iii) optimizing and integrating results. The results of these steps generate intermediate results that are stored as knowledge in order to reduce the overhead of the query evaluation process. The whole process is monitored to determine whether a computed SLA is being honoured while a query is evaluated. 

 Given a query, expressed as an SQL like expression including spatio-temporal attributes and preferences, for example, {\em List of energy providers that can provision 1000 Kwatts/h, in the next 10 seconds, that are close to my city with a cost of 0,50 euros/Kwatt?}. Assuming also that energy providers are represented by services exporting their SLA agreements and that can potentially be combined for answering the query. Thus, the whole query evaluation process is done through the following steps:


\begin{enumerate}

\item  {\bf Global SLA computation}. 
This first stage can be defined as a vertical mapping SLAs given the high level SLA described by the user (i.e. macroscopic constraints: execution time, pay / no pay, data reliability, data source). The system should be able to find relevant service compositions that respond to the query and, when combined, meet the constraints imposed by the user (High level SLA).

One may think to a first filter to remove the individual services which do not meet some or all of the constraints expressed by the user. 
To meet this objective, it is necessary to compare the SLA services to combine, in order to check if their joint use is compatible with the individual SLA. This step may lead either to the rejection of integration in case of total incompatibility, or to a negotiation between SLA which will lead us to the proposal for a negotiated SLA integration and thus the need for an adaptive setting.


 \begin{enumerate}
\item Computation of a global SLA given the existing possible SLA agreed by data providers that can be called for answering the query. Data providers are filtered in this way, since only those agreed SLA that can be combined into a global SLA that can fulfill the user preferences are considered for retrieving data.

  
  \item Filter the data providers that can potentially participate in the evaluation of the query taking into consideration the preferences associated to the query.
  
  \item Negociation of this type of SLA depends strongly on the request sent and the services deployed at the arrival time of the application on the cloud. This negotiation can be expensive and may not scale well.
  \end{enumerate}
  
  \item {\bf Rewrite the query.} See wether a similar Q has been already rewritten or rewrite it. Executing a query requires first a semantic analysis which will subdivide R into a set of sub-queries, in such a way that each sub-query can be processed by a DataService deployed on the cloud.   The subsueries represent the possible combination of services that can answer the initial query with given SLA.
 
  
  \item {\bf Optimize and execute subqueries.} Generate a service coordination search space that can compute each subquery and can integrate the global result. 
Each subquery is optimized with respect to user profile.

  \item Dispatch the execution of subqueries, integrate them into a result. Monitor the consumption of resources, the execution, time, behaviour ofi the services and make decisions
\end{enumerate}

%-----------------------------------------------------------------
\subsection{SLA model}
\label{sec:slaModel}
%-----------------------------------------------------------------

%\begin{itemize}
%\item Expression haut niveau du SLA en termes de préférences qui doit converger avec le SLA technique des services.
%  \begin{itemize}
%  \item (Souhait de temps de réponse, coût des services, espace de stockage,  
%  \item Templates pour exprimer le SLA
%  \item Intégration: modèle pivot de SLA
%\end{itemize}
%
%\item SLA violation contrôlée avec des mechanisms de monitoring.
%\item Que ce que devient l’intégration de données par rapport au SLA
%\item Création dynamique de SLA → niche de marché: étant donnée deux SLA fabriquer un SLA d’intégration
%\end{itemize}




%-----------------------------------------------------------------
\subsection{Query Rewriting}
\label{sec:queryRew}
%-----------------------------------------------------------------
%{\color{red}
%Here Martin will explain the rewriting problem.
%}

Query rewriting is a well-known problem for the database community.
The problem consists on transforming an abstract query into a set (or list) of lower-level queries to the available databases.
Traditionally, the abstract query is a query over a set of views and the lower-level queries are performed on the available databases whose information compose the view. 
The rewriting is guided by the schema of both abstract and concrete databases.
The answers to the lower level queries are combined in order to obtain the result to be returned to the user.

The query rewriting problem may be generalized to the case of services.
This is a natural consequence of the use of information-providing\footnote{Services that do not perform changes in the data they use.} services as interfaces over relational databases.
Both database queries and service invocations may be represented using a similar syntax.
Indeed, the interfaces to relational databases and information-providing services are exactly the same.
In the case of general services, the abstract query is seen as an abstract service composition, which is rewritten into a \textit{concrete} service composition.
The rewriting process is guided by the interfaces (types) of the abstract and concrete services.

Abstract services and database interfaces have some conspicuous differences.
Services may change information: Two different invocations may not return the same answer, even when given the same input data.
Also service compositions may need to meet some requirements such as QoS or other quality constraints that need to be verified.

Query rewriting techniques have been adapted to the context of service composition~\cite{queryRewriting}. 
In~\cite{UmbertoICWE2013} the authors present an algorithm to automatically refine high-level specifications of service compositions into lower-level ones. 
The method is based on the MiniCon algorithm~\cite{PH01} for query rewriting,  known in the database domain.
The proposed approach consists in generating several translations of an abstract service specification into compositions
over concrete  services. 
The solutions proposed are ranked and may be coded into concrete orchestrations. 


%-----------------------------------------------------------------
\subsection{Executing optimized queries}
\label{sec:queryOpt}
%-----------------------------------------------------------------


%-----------------------------------------------------------------
\subsection{Reducing the overhead of the evaluation process}
\label{sec:queryProcessOpt}
%-----------------------------------------------------------------
% Indeed, let consider a request R launched by a user who specifies a %number of constraints on the environment execution. 
  
 It is  crucial to provide proactive mechanisms for optimizing the production of such SLA. We believe that the optimization of this process can occur at two levels, firstly at the level of SLA previously traded, and secondly at the level of partial or total results. Indeed, queries requesting the same services compositions will have clauses in their SLAs that are more conditions of use of the infrastructure (ie not touching the data). For two different queries, they will be negotiated in the same way. These previously negotiated SLAs are reusable.

In a second time, we think optimizing this process on the data storage mechanisms to cache intermediate results, individually or in partial or complete combination depending on the terms of SLA services (data access, intermediate storage capacity , cost of storage , etc ... ).
Given this proposal, we identify several issues:
- Level modeling would require a model that allows the representation of SLA integration.
- There should also be a template for representing the requirements expressed by the user
- A mining component to identify, from the requirements expressed in the template by the user, and before the analysis of the application, the candidate integration SLA to use or adapt according to the request. This implies mapping between property and expressed clauses being.
